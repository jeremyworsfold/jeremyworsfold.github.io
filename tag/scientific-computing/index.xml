<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scientific Computing | Jeremy Worsfold</title>
    <link>https://jeremyworsfold.github.io/tag/scientific-computing/</link>
      <atom:link href="https://jeremyworsfold.github.io/tag/scientific-computing/index.xml" rel="self" type="application/rss+xml" />
    <description>Scientific Computing</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-gb</language><lastBuildDate>Mon, 21 Dec 2020 09:44:52 +0000</lastBuildDate>
    <image>
      <url>https://jeremyworsfold.github.io/media/face.jpg</url>
      <title>Scientific Computing</title>
      <link>https://jeremyworsfold.github.io/tag/scientific-computing/</link>
    </image>
    
    <item>
      <title>A Beginners Guide to using Balena</title>
      <link>https://jeremyworsfold.github.io/post/balenaguide/</link>
      <pubDate>Mon, 21 Dec 2020 09:44:52 +0000</pubDate>
      <guid>https://jeremyworsfold.github.io/post/balenaguide/</guid>
      <description>&lt;p&gt;This informal guide is for people new to using Balena and effectively want to take code they have written to run on their laptop in something like Python or MATLAB and now run it on Balena. This is by no means exhaustive and there is much more information on the &lt;a href=&#34;https://wiki.bath.ac.uk/display/BalenaHPC/Getting&amp;#43;Started&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki page&lt;/a&gt;. In fact, much of the information on Balena here is just condensed from that website. The rest of this guide is general tips on how to transfer files and navigate the environment.&lt;/p&gt;
&lt;h2 id=&#34;logging-onto-balena&#34;&gt;Logging onto Balena&lt;/h2&gt;
&lt;h3 id=&#34;purely-from-a-terminal&#34;&gt;Purely from a terminal&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;If you are on campus you can skip the first step and ssh directly into balena&lt;/strong&gt;. Otherwise open a terminal and type&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh user123@linux.bath.ac.uk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This opens up a link to the uni server (&lt;code&gt;ssh&lt;/code&gt; stands for secure shell). Put in your password and then do the same again but change linux to balena:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh user123@balena.bath.ac.uk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great, you are now in your personal home directory on balena.&lt;/p&gt;
&lt;h3 id=&#34;kitty&#34;&gt;Kitty&lt;/h3&gt;
&lt;p&gt;Using the image below taken from the &lt;a href=&#34;https://wiki.bath.ac.uk/display/BalenaHPC/Getting&amp;#43;Started&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wiki page&lt;/a&gt; should be sufficient in explaining how to login using Kitty.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://jeremyworsfold.github.io/media/kitty.png&#34; alt=&#34;how to login with kitty&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;transferring-data-or-files&#34;&gt;Transferring data or files&lt;/h2&gt;
&lt;p&gt;Since you are running your code on balena, you will at some point have to move around data using a terminal so I would recommend doing this for all the steps. The added benefit of this is that your commands are stored so you can always just reuse your previous commands using the up arrows if you can&amp;rsquo;t remember exactly what a command should be.&lt;/p&gt;
&lt;p&gt;To move files between your PC and balena you will sadly have to go through your uni drive unless you are on campus.&lt;/p&gt;
&lt;h3 id=&#34;from-h-drive-to-balena&#34;&gt;From H drive to balena&lt;/h3&gt;
&lt;p&gt;You can simply copy files across using linux &lt;code&gt;cp&lt;/code&gt; commands and the fact that your &lt;code&gt;H&lt;/code&gt; drive is called &lt;code&gt;$BUCSHOME&lt;/code&gt; on balena. For example, run the command&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cp -r folder/with/data $BUCSHOME/destination/folder
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to copy a folder with data from balena to your &lt;code&gt;H&lt;/code&gt; drive.&lt;/p&gt;
&lt;h3 id=&#34;from-local-pc-to-h-drive&#34;&gt;From local PC to H drive&lt;/h3&gt;
&lt;p&gt;You can transfer data to and from University personal drive from your PC by using &lt;code&gt;scp&lt;/code&gt; which stands for secure copy and essentially opens up a &lt;code&gt;ssh&lt;/code&gt; portal and then closes it again once the files are transferred.&lt;/p&gt;
&lt;h3 id=&#34;sending-files&#34;&gt;Sending files&lt;/h3&gt;
&lt;p&gt;Type one of these &lt;strong&gt;from within a terminal/kitty/putty on your PC&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;scp path/to/directory/f.txt user123@linux.bath.ac.uk:path/to/directory/
scp -r path/to/directory/ user123@linux.bath.ac.uk:path/to/directory/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first will transfer the file &lt;code&gt;file.txt&lt;/code&gt; whereas the second will transfer the whole directory.&lt;/p&gt;
&lt;h3 id=&#34;retrieving-files&#34;&gt;Retrieving files&lt;/h3&gt;
&lt;p&gt;This is the same as above but with the directories reversed in order, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;scp user123@linux.bath.ac.uk:path/to/remote/directory/file.txt path/to/local/directory/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively if you want, you can use something more familiar which is visual. For linux this would be mounting your Uni drive to your PC using a command called &lt;code&gt;sshfs&lt;/code&gt;. For Windows you can download an application called WinSCP which looks like it hasn&amp;rsquo;t changed since 2005 and basically hasn&amp;rsquo;t but it&amp;rsquo;s neat and very useful if that&amp;rsquo;s your thing. A quick google of either of these should give you the information you need. Finally you can use a browser to do this instead if you would like, see &lt;a href=&#34;https://www.bath.ac.uk/guides/access-and-share-your-work-online-using-files-bath/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3 id=&#34;where-do-i-store-my-files&#34;&gt;Where do I store my files?&lt;/h3&gt;
&lt;p&gt;So, I will be the first to admit that I have ran long jobs from my &lt;code&gt;$HOME&lt;/code&gt; directory. This is bad. It will work but it is faster and better apparently to run your jobs in the &lt;code&gt;$SCRATCH&lt;/code&gt;. It&amp;rsquo;ll be tedious at first but getting used to using simple commands like &lt;code&gt;cp&lt;/code&gt; and \verb!ls! will be really helpful. Make sure to save all of your results rather than just plotting graphs at the end, you never know when you might want to alter figures and need the original data again. I would recommend just saving your data and maybe copying it back to your PC to visualise the results. See my guide on how to layout and use a python package for a small research project for more detailed recommendations on how to handle results and plotting for Python specifically.&lt;/p&gt;
&lt;h2 id=&#34;jobscripts&#34;&gt;Jobscripts&lt;/h2&gt;
&lt;p&gt;The thing you run is the jobscript using the command&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sbatch &amp;lt;name of jobscript&amp;gt;.slm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below I&amp;rsquo;ve put in an example jobscript that has been adapted from the one given in the scientific computing module. Make sure you are in the directory of the jobscript when you call it and that the program you want to run is in the same folder or that you have specified where it is in the jobscript.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash 
#   
# Specify the queue
#SBATCH

# Choose name of job (name of executable) 
#SBATCH --job-name = &amp;lt;name of script&amp;gt;.py 
# Choose the number of nodes &amp;amp; processors per node: 
#SBATCH --nodes=1 
#SBATCH --ntasks-per-node=1 
# 
# Choose the time your code will need at most:
#SBATCH --time=05:00:00 
# Add any module which need to be loaded here 
module load python3

echo Running on host `hostname`
echo &amp;quot;Starting job...&amp;quot;
# Run the python script $SLUTM_JOB_NAME 
# If your script is in MATLAB obviously this needs to be changed
python3 $SLURM_JOB_NAME
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important bits to check are the job name and the time. For ease I have just made the job name the same as the name of the script you want to run. I&amp;rsquo;ll explain later what the job name is actually used for. Balena allows you free, unlimited usage for jobs which are under 6 hours long so make sure you know approximately how long it will take and change the time given accordingly. Nothing will happen if you overestimate how long you need but it could be helpful for other users to know when their jobs will start if balena is busy and puts your job in ahead of theirs.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;re using MATLAB and the paralellisation package thing that I know nothing about, you&amp;rsquo;ll want to change the number of tasks per node to the maximum of 16 I imagine. Otherwise, unless you&amp;rsquo;ve done clever things with the &lt;code&gt;MPI4pi&lt;/code&gt; or &lt;code&gt;multiprocessing&lt;/code&gt; packages in python (which I would highly recommend you learn about if you need to run long programs a lot because this could increase your speed by 16 times or more) then you will probably just be using the one processor and so don&amp;rsquo;t need to change anything.&lt;/p&gt;
&lt;h3 id=&#34;checking-jobs&#34;&gt;Checking Jobs&lt;/h3&gt;
&lt;p&gt;You will get an output file with the extension &lt;code&gt;.out&lt;/code&gt; telling you everything that happens in the job that would normally printed to the screen if you ran it from a terminal.&lt;/p&gt;
&lt;p&gt;To check your progress or see if the job has started you can find your jobs by typing&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;squeue -u user123
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>How to use Python for scientific research</title>
      <link>https://jeremyworsfold.github.io/post/post1/</link>
      <pubDate>Mon, 14 Dec 2020 21:44:52 +0000</pubDate>
      <guid>https://jeremyworsfold.github.io/post/post1/</guid>
      <description>&lt;p&gt;The world seems to be split into two types of projects. The ones maintained by software engineers committed to maintaining usability, robustness and efficiency of a package. Then there are those entitiled &lt;code&gt;simulation-2_old.py&lt;/code&gt; with cut and pasted code from previous versions which has only been looked at by one person. It might seem ovbious which is the better project but the word &lt;em&gt;better&lt;/em&gt; here is important.&lt;/p&gt;
&lt;p&gt;The context of what the code is for is crucial. If all was needed was a short simulation to demonstrate some result then perhaps the second type is a more efficient use of time. The importance of changeability and speed of implementation is an important factor in scientific research.&lt;/p&gt;
&lt;p&gt;This article tries to present to you a way of balancing these two extremes. There are always more things you can add to a project and this is what I have found works for me but my opinion may also change on what it necessary.&lt;/p&gt;
&lt;h2 id=&#34;general-things-we-want-our-project-to-do&#34;&gt;General things we want our project to do&lt;/h2&gt;
&lt;p&gt;No matter the language you&amp;rsquo;re working in I believe these core ideas are things we want to embody in our project. The main point of them is to give yourself a consistent structure to adapt code and test out new things while maintaining a system and making sure someone else could use it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Save data&lt;/strong&gt;: Saving the results of simulations or processing data is incredibly important. It can be tempting to just make some changes and see what happens but then find out those results would have been useful to revisit and either it takes a while to run them again or you can&amp;rsquo;t remember the parameters you chose. Saving data in an easily understandable format can lots of time in the long run.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Separation between visualising results and the simulations or preprocessing&lt;/strong&gt;: This point follows on from the previous one because if we save our data from the early stages of our workflow then we should be able to load it in an produce all the plots we need from that data. We&amp;rsquo;ve all been there when you realise you labelled your axes incorrectly on a plot of some results which took a couple of hours to run and you don&amp;rsquo;t have the raw data available any more. I&amp;rsquo;ll give more details on why this might be useful later.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Good Documentation&lt;/strong&gt;: Writing documentation such that a layperson could understand you code is definitely too much to ask and is not relevant but it should be good enough that a person familiar with the programming language and the field or research would be able to follow what you have done and why.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distribution&lt;/strong&gt;: If your work eventually gets published it would be great if a reader could look at your code and run it for themselves so that they can gain the same level of trust in your code as they have for whatever mathematical proofs you have in the text.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;why-python&#34;&gt;Why Python?&lt;/h2&gt;
&lt;p&gt;Before saying anything else in this section I will acknowledge that ultimately this comes down to personal preference. Each person develops their own style of working and habits or have a specific field of research which lend themselves to particular languages. Before deciding which language to use, consider things such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support for the things you would like to do: Are there packages associated with the things you want to code in a certain language which will make your life easier?&lt;/li&gt;
&lt;li&gt;Do you know the language already?: Rarely much use in starting from scratch with a language if it&amp;rsquo;s a small project unless you are particularly interested in learning a new language.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With that out the way, here is my biased case for why python is good for small research projects. The typical cyclical argument for python is that lots of people use so you should use it too. There is a huge community of people using it so chances are there will be applicable, well-maintained packages out there to help you do the things you want.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s incredibly flexible so if the scope of your project changes it&amp;rsquo;s relatively easy to adapt your code or just extend it to add new features. Since this is a small project it&amp;rsquo;s nice to not have to worry about what is sometimes called &lt;em&gt;boiler plate code&lt;/em&gt; which can plague lower level languages. Lower level languages often insist you specify the types of your variables or defines destructors to your classes or how data is copied between classes. All of this often allows the code to run faster and ensures it does exactly what you want but slows down your start when all you really want to do is see if your idea works initially.&lt;/p&gt;
&lt;p&gt;Python is rarely the most efficient or fastest language to use out of the box compared with things like MATLAB or R if you use them correctly. However, there is always scope for increasing the efficiency of your code in Python down the line. Initally this can just be making sure you have optimised your code with vectorisation through using numpy. Going deeper you can use things such as the Multiprocessing or MPI4py modules for parallel computing or you could convert the core aspects of your code to Cython or pure C code which can greatly increase the speed of your code. The details of how to do this and the benefits of it might be the subject of a blog another time.&lt;/p&gt;
&lt;h2 id=&#34;how-to-structure-your-python-project&#34;&gt;How to Structure your Python project&lt;/h2&gt;
&lt;p&gt;This is how I&amp;rsquo;ve chosen to layout my projects, it follows the standard for python packages but has some tweaks for using as a personal project which may not be considered best practice but is relatively easy to use.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exampleproject
│   README.md
│   setup.py
│
├───data
├───docs
│       optional-documentation.md
├───exampleproject
│   │   __init__.py
│   │
│   ├───environment
│   │       base.py
│   │       derived.py
│   │       __init__.py
│   │
│   └───otherfiles
│           utils.py
│           __init__.py
│
├───notebooks
│       01-feature1.ipynb
│       02-feature2.ipynb
│
└───scripts
        feature1.py
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;documentation-and-commenting&#34;&gt;Documentation and Commenting&lt;/h2&gt;
&lt;h2 id=&#34;presenting-your-findings&#34;&gt;Presenting your findings&lt;/h2&gt;
&lt;p&gt;I find as well that a significant amount of the experimentation happens in the plotting of the raw data. Given some underlying simulation I might want to try out all sorts of different plots and so having the raw data saved allows me to quickly try out visualising a variety of features. Having said this, it can be useful to visualise one or two things while you are producing your data to give you confidence it is all behaving as it should.&lt;/p&gt;
&lt;p&gt;number them so there&amp;rsquo;s some structure but maybe not necessary&lt;/p&gt;
&lt;p&gt;load in results, can then just plot it and convert it to some other format to be plotted professionally like pgfplots.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to use Python for scientific research</title>
      <link>https://jeremyworsfold.github.io/slides/python-coding/</link>
      <pubDate>Mon, 14 Dec 2020 21:44:52 +0000</pubDate>
      <guid>https://jeremyworsfold.github.io/slides/python-coding/</guid>
      <description>&lt;h2 id=&#34;how-to-use-python-for-scientific-research&#34;&gt;How to use Python for scientific research&lt;/h2&gt;
&lt;h3 id=&#34;maintaining-a-personal-python-package-for-scientific-research&#34;&gt;Maintaining a personal Python package for scientific research&lt;/h3&gt;
&lt;hr&gt;
&lt;h2 id=&#34;our-project-should&#34;&gt;Our project should&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Save data&lt;/li&gt;
&lt;li&gt;Separate plotting from time-consuming code&lt;/li&gt;
&lt;li&gt;Have good documentation&lt;/li&gt;
&lt;li&gt;Be Distributable&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;why-python&#34;&gt;Why Python?&lt;/h2&gt;
&lt;p&gt;It is personal preference however&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;layout&#34;&gt;Layout&lt;/h2&gt;
&lt;p&gt;Root directory&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;exampleproject
│   README.md
│   setup.py
│
├───data
├───docs
├───exampleproject
├───notebooks
└───scripts
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
